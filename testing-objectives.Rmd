---
title: "testing work flow with objective functions"
author: "ACS"
date: "5/25/2020"
output: 
  html_document:
      toc: true
      toc_float: true
      toc_depth: 4
      number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(gcamland)
library(dplyr)
library(tidyr)
```

# Motivation/notes

- Operate on a truncated version of the `run_ensemble` function for testing and developing analysis work flow with objective functions:
`run_ensemble_no_analysis`. This version removes the `lpdf` and `lprior` arguments as well as the `if` statement that launches `run_bayes`. 
This seems like a cleaner way to support two different styles of analysis; otherwise, we'd have to add more arguments to `run_ensemble` to 
specify which objective functions to use, and unless a run was doing both bayesian and objective function analysis, only a subset of the 
arguments would ever be used. Seems cleaner to the do the run and break out the analysis after the fact, whether bayesian or objective function.
- This approach will rely on some of the utility functions defined in `bayesian.R` like `get_historical_land_data`. These have been
moved to their own script, and some have been updated from `internal` to `export` so that they can still be called from `bayesian.R` functions.

- Adding a sentence so the PR will re-run tests.

# Setup params

Pick the number of runs to do

```{r}
Nruns <- 3
```

# Do run with  `run_ensemble_no_analysis`

```{r}
set.seed(1)

scenObjects <- invisible(run_ensemble_no_analysis(N=Nruns))
```

# Test `run_objective`

- Right now, the `run_objective` function evaluates user-specified objective function for each land type separately. Certainly _can_ give an argument wither fewer land types.
- idea is that it's all so fast and not that big, just go ahead and calculate for each land type. Then when we call `MAP_objective` (which we should probably pick a different name for), _that_ function also takes a list of land types of interest, averages the objective function across those land types, and then picks the parameter set that gives you the smallest average objective function value (ie minimized error) across those land types.
- Also, currently, from `get_historical_land_data` in `utility-functions-analysis.R` (previously in `bayesian.R`), this only supports comparison to FAO GCAM commodities - mostly crop data and not Forest or anything. A note to change this is included in the documentation of `MAP_objective`.



```{r}

scenObjectsEvaluated <- run_objective(scenObjects)

str(scenObjectsEvaluated)

names(scenObjectsEvaluated[[1]])

knitr::kable(head(scenObjectsEvaluated[[1]]$mObjFunEval))

```

# Test `grand_table_objective`
```{r}
grand_table_objective(aScenarioList = scenObjectsEvaluated) %>%
  # these lines of code are because the `left_join` in 
  # `add_parameter_data` (from utility-functions-analysis.R) is only
  # a join on scenario, rather than scenario and region.
  # Unclear if should update that join or if we somehow want to keep it
  # separate; ideally will figure out more when do other regions.
  # For now, leaving it alone so that the `grand_table` works as it
  # did before. 
  # (relevant because both `grand_table` and `grand_table_objective`
  # call `add_parameter_data`)
  filter(region.x == region.y) %>%
  rename(region = region.x) %>%
  select(-region.y) ->
  GTobjective

knitr::kable(head(GTobjective))

# make pretty - decided not to do this in the function but can definitely add.
# Decided not to add in because makes filtering in the `MAP_objective` function
# to the single objective function of interest easier. But we can easily add
# this code into `grand_table_objective` to make the output of that pretty, and 
# then add code to `MAP_objective` to make un-pretty and easier filtering.
GTobjective %>%
  spread(objfun, objfunval) ->
  GTobjective_pretty

knitr::kable(head(GTobjective_pretty))
```


# Test `MAP_objective`

- TODO: figure out if min values getting selected are all the same because only 10 runs or ......


## default argument

Default arguments of `MAP_objective` currently is focused on RMS for all GCAM commodities ` c( "Corn", "FiberCrop", "MiscCrop", "OilCrop", "OtherGrain", "PalmFruit",  "Rice", "Root_Tuber", "SugarCrop",  "Wheat")` that we run and have FAO comparison data for. 

`MAP_objective` is taking the average of RMS across all of these land types, and selecting the parameter set that minimizes that quantity.

Currently no support for mixing and matching different objective functions for different crops. Seems doable but not implemented yet (eg maybe you want parameters that minimize both Corn's bias and OtherGrain's KGE.)


```{r}

knitr::kable(MAP_objective(GTobjective))

```


## Corn, OilCrop bias example

Select parameters that minimize the average (absolute value of) bias in Corn and OilCrop

- Current implementation does not allow for cancellation of errors because of absolute value included in `MAP_objective`. So being over in Corn and under in OilCrop won't cancel out and help you.


```{r}

knitr::kable(MAP_objective(GTobjective, objfun_to_min = 'bias', landtypes = c('Corn', 'OilCrop')))

```

## OtherGrain rms example

```{r}

knitr::kable(MAP_objective(GTobjective, objfun_to_min = 'rms', landtypes = c('OtherGrain')))

```


